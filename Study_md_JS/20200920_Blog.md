## JS 우아한 형제들 Blog

#### JS 변수 선언
###### var
함수를 단위로 스코프를 갖는다.
함수 범위 단위를 변수로 사용할 수 있다.
호이스팅이 유일하게 가능하다.(let, const는 적용되지 않음)

###### let
블록 단위로 스코프를 갖는다.
재할당이 가능하다.
###### const
블록 단위로 스코프를 갖는다.
재할당이 불가능하다.
다만 참조형 타입의 안에 데이터는 변경이 가능하다.
#### JS의 타입
원시타입은 메모리에 직접 갚을 담는다.
참조타입은 메모리에 값을 담은 주소를 담는다.
변수를 복사할 때, 비교할 때 const를 사용한다.
#### JS 의 함수
JS에서 함수는 객체이다.
변수에 할당이 가능하다.
함수는 return으로 값을 반환하고, return이 없으면 undefined를 반환한다.
문 뒤에는 ;를 찍지 않지만 식 뒤에는 찍는다.
+ 값을 선언, 할당 -> 식
+ 함수선언, if문, 반복문 -> 문
재귀함수를 구현하기 위해서는 함수의 이름이 필요하다.
###### IIFE(즉시 실행 함수 표현)
함수를 선언과 동시에 실행시킨 후 사라진다.
###### 화살표 함수
this를 다른 함수처럼 사용할 수 없다.
화살표 함수 바깥의 this값이 화살표 함수의 this값이 된다.
화살표 함수 안에는 유사 배열 형태인 arguments 변수가 없다.
#### class
객체는 참조타입이기 때문에 .name 값에 접근해서 직접 변경이 가능하다.
class처럼 생성자 함수를 활용해 인스턴스를 만들 수 있다.
생성자 함수를 인스턴스 생성에만 사용하도록 강제할 수 없다.
instanceof를 이용해 생성자 함수인지 인스턴스인지 확인할 수 있다.
#### 클로저
입력된 값을 가비지 컬렉션이 지우지 않고 기억하고 있다가 실행 시점에 값을 활용하는 것
객체는 외부에 쉽게 값을 변경할 수 있다.
#### 비동기
첫번째 매개변수로 받은 함수를 두번째 매개변수로 받은 시간만큼 기다렸다가 실행하는 함수
promise는 비동기 작업을 함수 안에 함수 구조 대신 체이닝 구조로 일렬로 볼 수 있게 해준다.
성공하면 then을 사용, then은 resolve를 호출한다.
실패하면 catch를 사용, reject를 호출한다.