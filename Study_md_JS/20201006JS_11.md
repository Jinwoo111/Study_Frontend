# 객체와 변경불가성(Immutability)

Immutability는 객체가 생성된 이후 그 상태를 변경할 수 없는 디자인 패턴을 의미한다.

객체는 참조 형태로 전달하고 전달 받는다. 객체가 참조를 통해 공유되어 있다면 그 상태가 언제든지 변경될 수 있기 때문에 문제가 될 가능성도 커지게 된다. 이는 객체가 참조를 가지고 있는 어떤 장소에서 객체를 변경하려면 참조를 공유하는 모든 장소에서 그 영향을 받기 때문인데 이것이 의도한 동작이 아니라면 참조를 가지고 있는 다른 장소에 변경 사실을 통지하고 대처하는 추가 대응이 필요하다.

### Immutable value vs mutable value
원시 타입은 변경 불가능한 값이다.
+ Boolean
+ null
+ undefined
+ Number
+ String
+ Symbol
원시 타입 이외에는 객체 타입이고 변경 가능하다. 객체는 새로운 값을 다시 만들 필요 없이 직접 변경이 가능하다.

### 불변 데이터 패턴

이러한 객체의 변경의 원인은 "래퍼런스를 참조한 다른 객체에서 객체를 변경"이 대부분이다.
해결 방법은 객체를 불변객체로 만들거나 **Observer 패턴**으로 객체의 변경에 대처한다.
이를 정리하면
+ 객체의 방어적 복사(defensive copy)
	Object.assign
+ 불변객체화를 통한 객체 변경 방지
	Object.freeze
##### Object.assign
Object.assign은 타깃 객체로 소스 객체의 프로퍼티를 복사한다. 이 때 소스 객체의 프로퍼티와 동일한 프로퍼티를 가진 타겟 객체의 프로퍼티들은 소스 객체의 프로퍼티로 덮어쓰기 된다. 리턴 값으로 타깃 객체를 반환한다.
기존 객체를 변경하지 않고 객체를 복사하여 사용할 수 있다. 하지만 완전한 deep copy를 지원하지 않는다.

##### Object.freeze
이를 사용하여 불변 객체로 만들 수 있다. 하지만 객체 내부의 객체(Nested Object)는 변경 가능하다.
내부 객체까지 변경 불가능하게 만들려면 Deep freeze를 하여야 한다.

##### Immutable.js
위에 나온 둘은 방법이 번거롭고 성능상 이슈로 인해 큰 객체에서는 사용하지 않는다.
Immutable.js는 대안으로 Facebook이 제공한다. 이는 영구 불변 데이터 구조를 제공한다.