# 함수 호출 방식에 의해 결정되는 this
자바스크립트는 함수를 호출할 때, 인자 외에, argument 객체와 this를 암묵적으로 전달 받는다.
자바스크립트의 this는 인스턴스 자신을 가리키는 참조변수이다. this가 객체 자신에 대한 참조 값을 가지고 있다. 주로 매개변수와 객체 자신이 가지고 있는 인스턴스 명이 같을 경우 이를 구분하기 위해 사용한다. 자바스크립트는 Java와 같이 this에 바인딩되는 객체는 한가지가 아니라 해당 함수 호출 방식에 따라 this에 바인딩되는 객체가 달라진다.

### 함수 호출 방식과 this 바인딩
JS의 경우 함수 호출 방식에 의해 this에 바인딩할 어떤 객체가 동적으로 결정된다. 즉, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this가 바인딩할 객체가 동적으로 결정된다.
```
함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수를 선언할 때 결정된다.
this 바인딩과 혼동하지 않도록 주의하기 바란다.
```
###### 함수의 호출하는 방식
```
1. 함수 호출
2. 메소드 호출
3. 생성자 함수 호출
4. apply / call / bind 호출
```

### 함수 호출
전역객체는 모든 객체의 유일한 최상위 객체이다. 일반적으로 Browser-side에서 window, Server-side에서는 global 객체를 의미한다.

전역객체는 전역 스코프를 갖는 전역변수를 프로퍼티로 소유한다. 글로벌 영역에 선언한 함수는 전역객체의 프로퍼티로 접근할 수 있는 전역변수의 메소드이다. this는 전역객체에 바인딩된다.

내부함수는 어디에서 선언되었든 관계없이 this는 전역 객체를 바인딩한다.

### 메소드 호출
함수가 객체의 프로퍼티 값이면 메소드로서 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체에 바인딩된다. 물론 프로토타입 객체도 메소드를 가질 수 있다.

### 생성자 함수 호출
생성자 함수는 객체를 생성하는 역할을 한다. 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.

##### 생성자 함수 동작 방식
동작의 순서
```
1. 빈객체 생성 및 this 바인딩
생성자 함수의 코드가 실행되기 전 빈 객체를 가리킨다. 이 빈 객체가 생성자 함수가 새로 생성하는 객체이다. 이후 생성자 함수 내에서 새용되는 this는 이 빈 객체를 가리킨다.

2. this를 통한 프로퍼티 생성
생성된 객체에 this를 사용하여 동적으로 메소드나 프로퍼티를 생성할 수 있다.

3. 생성된 객체 반환
반환문이 없는 경우, this에 바인딩된 새로 생성한 객체가 반환된다. 명시적으로 this를 반환하여도 결과는 같다.
반환문이 this가 아닌 다른 객체인 경우, this가 아닌 해당 객체가 반환되고, this를 반환하지 않은 함수는 생성자 함수로서의 역할을 수행하지 못한다/.
```
##### 객체 리터럴 방식과 생성자 함수 방식의 차이
객체 리터럴 방식과 생성자 함수 방식의 차이는 **프로토타입 객체([[Prototype]])**에 있다.
+ 객체 리터럴 방식은 생성된 객체의 프로토타입 객체는 Object.prototype이다.
+ 생성자 함수 방식의 경우, 생성된 객체의 프로토타입은 Person.prototype이다.

###### 생성자 함수에 new 연산자를 붙이지 않고 호출할 경우
** 일반함수와 생성자 함수에 특별한 형식적 차이는 없으며 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. **
일반 함수를 호출하면 this는 전역객체에 바인딩 되지만 new 연산자와 함께 생성자 함수를 호출하면 this는 생성자 함수가 암묵적으로 생성한 빈 객체에 바인딩된다.

```
callee는 arguments 객체의 프로퍼티로서 함수 바디 내에서 현재 실행 중인 함수를 참조할 때 사용한다. 다시 말해, 함수 바디 내에서 현재 실행 중인 함수의 이름을 반환한다.
```

### apply / call / bind 호출
자바스크립트 엔진의 암묵적 this 바인딩 이외에 this를 특정 객체에 명시적으로 바인딩하는 방법도 제공된다. 이것을 가능하게 하는 것이 Function.prototype.apply, Function.prototype.call 메소드이다. 이 메소드들은 모두 Function.prototype 객체의 메소드이다.

apply() 메소드를 호출하는 주체는 함수이며 apply()메소드는 this를 특정 객체에 바인딩할 뿐 본질적인 기능은 함수 호출인다. apply() 메소드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메소드를 사용하는 경우이다. arguments 객체는 배열이 아니기 때문에 slice() 같은 배열의 메소드를 사용할 수 없으나 apply()메소드를 이용하면 가능하다.

call 메소드의 경우 apply()와 기능은 같지만 apply()의 두 번째 인자에서 배열 형태로 넘긴 것을 각각 하나의 인자로 넘긴다.

apply()와 call() 메소드는 콜백 함수의 this를 위해서 사용되기도 한다.